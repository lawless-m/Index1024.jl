<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Data · Index1024.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Index1024.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index1024.jl</a></li><li class="is-active"><a class="tocitem" href>The Data</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Creating-the-Keyset"><span>Creating the Keyset</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lawless-m/Index1024.jl/blob/master/docs/src/example1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>layout: page title: &quot;PAGE TITLE&quot; Example Indexing of a CSV file ==============================</p><h1 id="The-Data"><a class="docs-heading-anchor" href="#The-Data">The Data</a><a id="The-Data-1"></a><a class="docs-heading-anchor-permalink" href="#The-Data" title="Permalink"></a></h1><p>The CSV file I wish to index contains the data from the UK Land Registry.  https://www.gov.uk/guidance/about-the-price-paid-data This records the value of every house sale in England and Wales. I have gathered the data from 2000 onwards and extracted the following dataset. The postcode, year and price of every transaction.</p><p>What I want is to be able to extract the list of year / price entries for a particular postcode.</p><pre><code class="nohighlight hljs">postcode,year,price       
AL10 0AB,2000,63000       
AL10 0AB,2003,126500      
AL10 0AB,2003,167000      
AL10 0AB,2003,177000      
AL10 0AB,2004,125000      
AL10 0AB,2013,220000      
AL10 0AB,2014,180000      
⋮
YO8 9YB,2021,269950
YO8 9YD,2011,230000
YO8 9YD,2012,249999
YO8 9YD,2018,327500
YO8 9YE,2009,320000
YO8 9YE,2019,380000
YO8 9YE,2020,371500
YO90 1UU,2017,15500000
YO90 1WR,2015,28100000
YO91 1RT,2017,150000</code></pre><p>13,193,754 lines, including the header. The file size is 267,473,752 bytes.</p><p>In the Index I can store the Named Tuple <code>(data:UInt64, aux:UInt64)</code> for each <code>UInt64</code> Key.</p><p>So what I shall do is to store the file offset of the first postcode entry in the data and the number of rows in the aux.</p><p>It just so happens that the postcode is, at most, 7 characters long, so this can be converted into a UInt64 with a byte spare the the tag.</p><p>By turning the postcodes into a fixed format from</p><pre><code class="nohighlight hljs">YO8 9YE
YO90 1UU</code></pre><p>to</p><pre><code class="nohighlight hljs">YO 8 9YE
YO90 1UU</code></pre><p>we can also make the process reversible.</p><p>Here are the functions to do this</p><pre><code class="nohighlight hljs">function postcode_to_UInt64(pc) 
    m = match(r&quot;([A-Z]+)([0-9]+([A-Z]+)?) ?([0-9]+)([A-Z]+)&quot;, replace(pc, &quot; &quot;=&gt;&quot;&quot;))
    if m == nothing || m[1] === nothing || m[2] === nothing || m[4] === nothing || m[5] === nothing
        return 0
    end
    reduce((a,c) -&gt; UInt64(a) &lt;&lt; 8 + UInt8(c), collect(lpad(m[1], 2) * lpad(m[2], 2) * m[4] * m[5]), init=0)
end

function UInt64_to_postcode(u)
    cs = Char[]
    while u &gt; 0
        push!(cs, Char(u &amp; 0xff))
        u &gt;&gt;= 8
    end
    part(cs) = replace(String(reverse(cs)), &quot; &quot;=&gt;&quot;&quot;)
    &quot;$(part(cs[4:end])) $(part(cs[1:3]))&quot;
end</code></pre><h1 id="Creating-the-Keyset"><a class="docs-heading-anchor" href="#Creating-the-Keyset">Creating the Keyset</a><a id="Creating-the-Keyset-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-Keyset" title="Permalink"></a></h1><p>So, now iterate over the data and create the Keyset</p><pre><code class="nohighlight hljs">function count_lines(io, pcode)
    lines = 0
    pos = position(io)
    while (line = readline(io)) !== nothing
        lines += 1
        newcode = split(line, &quot;,&quot;, limit=2)[1]
        if newcode != pcode
            return newcode, lines, pos
        end
        pos = position(io)
    end
    return &quot;&quot;, lines, pos
end

create_kvs(fname) = open(create_kvs, fname)

function create_kvs(io::IO)
    kvs = Dict{UInt64, DataAux}()
    readline(io)
    pos = position(io)
    pcode, lines, nextpos = count_lines(io, &quot;postcode&quot;)
    while pcode != &quot;&quot;
        newcode, lines, nextpos = count_lines(io, pcode)
        kvs[postcode_to_UInt64(pcode)] = (data=pos, aux=lines)
        pcode = newcode
        pos = nextpos
    end
    kvs
end</code></pre><p>It&#39;s not really necessary to understand how all that works (in fact my first version was wrong!), just know that when we run it</p><pre><code class="nohighlight hljs">julia&gt; create_kvs(&quot;pc_year_price.csv&quot;)</code></pre><p>we get something like the following Dictionary</p><pre><code class="nohighlight hljs">Dict{UInt64, NamedTuple{(:data, :aux), Tuple{UInt64, UInt64}}} with 4 entries:
  0x00594f2038395942 =&gt; (data = 0x00000000000000e6, aux = 0x0000000000000007)
  0x00594f2038395945 =&gt; (data = 0x0000000000000136, aux = 0x0000000000000009)
  ⋮
  0x00414c3130304142 =&gt; (data = 0x0000000000000536, aux = 0x0000000000000027)
  0x00594f2038395944 =&gt; (data = 0x0000000000000bfa, aux = 0x0000000000000013)</code></pre><p>The keys are the encoded postcodes e.g.</p><p><code>&quot;AL10 0AB&quot;</code> becomes <code>0x00414c3130304142</code> and at offset 0x536 in the CSV files, has 0x27 rows of data</p><p>Which is the format of the keyset we need to build the actual index.</p><p>That part of the process is in the modules</p><pre><code class="nohighlight hljs">julia&gt; @time build_index_file(&quot;Postcode_Year_Price.index&quot;, create_kvs(&quot;pc_year_price.csv&quot;))
 10.181108 seconds (83.94 M allocations: 6.096 GiB, 10.57% gc time)
42453022</code></pre><p><code>build_index_file</code> returns the number of bytes written</p><p>So now in my pwd() is the index file</p><p><code>42453022 Jan 18 13:56 Postcode_Year_Price.index</code></p><p>At 41M it is only a bit smaller than the 256M of <code>pc_year_price.csv</code> but to explore it, we don&#39;t need to have it in memory.</p><p>If we open the index we get</p><pre><code class="nohighlight hljs">julia&gt; idx = open_index(&quot;Postcode_Year_Price.index&quot;)
 NI key:0x1053522036384146 value: (LR left: NI key:0x2053522036384146 value:(Leaf data:0x000000000287c576 aux:0x0000000000000000) right: NI key:0x20594f3931315254 value:(Leaf data:0x000000000287c76e aux:0x0000000000000000))</code></pre><p>This is the root node of the first page. This example is rather shallow, but that is an artefact of the number of data Leafs.</p><p>We can search this idx </p><pre><code class="nohighlight hljs">julia&gt; get_leaf(idx, postcode_to_UInt64(&quot;YO8 9YB&quot;))
 NI key:0x30594f2038395942 value:(Leaf data:0x000000000ff15226 aux:0x0000000000000007)</code></pre><p>How quick is this? </p><pre><code class="nohighlight hljs">julia&gt; @benchmark get_leaf($idx, $postcode_to_UInt64(&quot;YO8 9YB&quot;))
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  32.455 μs …  3.829 ms  ┊ GC (min … max): 0.00% … 97.92%
 Time  (median):     35.409 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   36.733 μs ± 52.923 μs  ┊ GC (mean ± σ):  2.01% ±  1.38%

    ▃█▆▄▅▄▃▆█▆▅▅▃     ▄▅▃                                      
  ▂▅██████████████▆▅▅█████▇▅▄▅▄▃▃▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▄
  32.5 μs         Histogram: frequency by time        46.5 μs &lt;

 Memory estimate: 9.31 KiB, allocs estimate: 247.</code></pre><p>Certainly a lot slower (20x) than reading it straight from memory. </p><p>But at least doesn&#39;t need the whole kvs in memory</p><p>What we don&#39;t have, though, is the actual data. So let&#39;s write an accessor function for that.</p><pre><code class="nohighlight hljs">prices_for_postcode(idx, pcode, csvfile) = open(csvfile) do io prices_for_postcode(idx, pcode, io) end
        
function prices_for_postcode(idx, pcode, csvio::IO)
    (offset, lines) = get(idx, postcode_to_UInt64(pcode), (0,0))
    if lines &gt; 0
        seek(csvio, offset)
        return CSV.File(csvio; header=[&quot;postcode&quot;, &quot;year&quot;, &quot;price&quot;], limit=lines)
    end
end</code></pre><p>We write two functions, one which takes a filename and one which takes an IO. That way we can perform either a single lookup or multiple lookups without opening / closing the file (or use an IOBuffer instead of a file and go full circle!)</p><p>The function finds a Leaf node. Remembering the data is the offset and the aux the number of rows, we can then read the rows as CSV from the file.</p><pre><code class="nohighlight hljs">julia&gt; prices_for_postcode(idx, &quot;YO8 9YB&quot;, csvfile)
7-element CSV.File:
 CSV.Row: (postcode = &quot;YO8 9YB&quot;, year = 2000, price = 59500)
 CSV.Row: (postcode = &quot;YO8 9YB&quot;, year = 2000, price = 95000)
 CSV.Row: (postcode = &quot;YO8 9YB&quot;, year = 2009, price = 230000)
 CSV.Row: (postcode = &quot;YO8 9YB&quot;, year = 2014, price = 222000)
 CSV.Row: (postcode = &quot;YO8 9YB&quot;, year = 2014, price = 237000)
 CSV.Row: (postcode = &quot;YO8 9YB&quot;, year = 2018, price = 142500)
 CSV.Row: (postcode = &quot;YO8 9YB&quot;, year = 2021, price = 269950)</code></pre><p>We could also create a DataFrame from this data, if we were so inclined</p><pre><code class="nohighlight hljs">julia&gt; LR.prices_for_postcode(idx, &quot;YO8 9YB&quot;, csvfile) |&gt; DataFrame
7×3 DataFrame
 Row │ postcode  year   price  
     │ String7   Int64  Int64  
─────┼─────────────────────────
   1 │ YO8 9YB    2000   59500
   2 │ YO8 9YB    2000   95000
   3 │ YO8 9YB    2009  230000
   4 │ YO8 9YB    2014  222000
   5 │ YO8 9YB    2014  237000
   6 │ YO8 9YB    2018  142500
   7 │ YO8 9YB    2021  269950</code></pre><p>Creating this document revealed that <code>node_range</code> is broken, so I won&#39;t write that up at the moment.</p><p>In the future work, I plan to incorprate SeaweedFS into the Index. So we could use this index along with Distributed. But that&#39;s another project!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Index1024.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 18 January 2022 16:00">Tuesday 18 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
